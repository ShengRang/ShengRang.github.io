<!DOCTYPE html>
<html lang="">
  <head><meta charset="UTF-8"/>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="poll 笔记"/><meta name="keywords" content="kernel, 网络编程, 乌云制作法" /><link rel="alternate" href="/atom.xml" title="乌云制作法"><link rel="shortcut icon" type="image/x-icon" href="/images/lucid5.jpg?v=2.11.1" />
<link rel="canonical" href="https://blog.runc.dev/2021/12/19/poll-note/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.1" />

<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>poll 笔记 - 乌云制作法</title>
  <meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">乌云制作法</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">乌云制作法</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">poll 笔记
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-12-19
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#背景"><span class="toc-text">背景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一些迷惑问题"><span class="toc-text">一些迷惑问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#联想到的一些问题"><span class="toc-text">联想到的一些问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前置知识"><span class="toc-text">前置知识</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#select-poll-分析"><span class="toc-text">select&#x2F;poll 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#select-实现"><span class="toc-text">select 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll-机制，以-tcp-poll-和-select-为例"><span class="toc-text">poll 机制，以 tcp_poll 和 select 为例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#epoll-实现分析"><span class="toc-text">epoll 实现分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#零碎"><span class="toc-text">零碎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-发送-POLLIN-POLLOUT-的时机"><span class="toc-text">tcp 发送 POLLIN&#x2F;POLLOUT 的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-poll-的一个-patch"><span class="toc-text">select&#x2F;poll 的一个 patch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll-的一个-patch"><span class="toc-text">epoll 的一个 patch</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#感想"><span class="toc-text">感想</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>又翻了翻 poll 的内核源码，记点笔记。</p>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>select, poll, epoll 系列系统调用可以让内核监听事件的发生，提高（网络） IO 性能。也是八股文重灾区，记得校招的时候经常会被问，但大多简短的八股文文章也并没有讲清楚，问题和答案也都比较套路化。</p>
<h2 id="一些迷惑问题"><a href="#一些迷惑问题" class="headerlink" title="一些迷惑问题"></a>一些迷惑问题</h2><p>看到过一些迷惑问题和迷惑回答…</p>
<h2 id="联想到的一些问题"><a href="#联想到的一些问题" class="headerlink" title="联想到的一些问题"></a>联想到的一些问题</h2><p>epoll 用了回调机制所以性能好，那么 select/poll 事件通知用的是什么机制，是轮询吗？如果是轮询，内核是怎么做到同时轮询多个事件的？</p>
<p>epoll 的回调方式具体是怎么做的？如果说是和设备驱动程序或者设备就绪队列产生关联，这就有个问题，一张网卡可以同时收发多个 tcp 连接的数据，从设备的角度看确实产生了数据变化，但某个 tcp 连接上未必发生了事件。</p>
<p>ET 和 LT 的实现方式区别，以及和 poll/select 的实现区别。一个 socket fd 上有网络数据可读，此时先 ep_insert，et 模式。然后 ep_poll，期间这个 tcp 连接上没有数据到达，此时 ep_poll 能不能报告 fd 上有可读事件。</p>
<p>同一个 file 被两个 task poll 是什么表现？</p>
<p>tcp socket 上发出有网络数据可读事件 (POLLIN) 的时机是什么？发出 POLLOUT 的时机又是什么？</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这只是个瞎写的零碎记录，不是完整的知识。假设对内核，调度(task, sched, wakeup, wait queue)，vfs，网络(socket, sock, tcp) 有基本认识。<br>本来想对着 5.x 写，但新内核这些实现细节更多了，写起来繁琐，所以还是换回了 2.6.24，大差不差，感兴趣可以自己翻翻高版本内核。</p>
<h1 id="select-poll-分析"><a href="#select-poll-分析" class="headerlink" title="select/poll 分析"></a>select/poll 分析</h1><p>把 select 和 poll 放一起是因为这俩很像，而且实现都在同一个文件里 （select.c）。</p>
<h2 id="select-实现"><a href="#select-实现" class="headerlink" title="select 实现"></a>select 实现</h2><p>从 syscall 入口到关键函数，syscall 都差不太多，sys_select -&gt; kern_select -&gt; core_sys_select -&gt; do_select。注意 sys_select 在高版本内核是用 SYS_DEFINEx 宏产生的，直接搜符号未必搜的到。</p>
<p>先看一下 do_select 函数，有个大概认识。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/select.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, s64 *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    poll_table *wait;</span><br><span class="line">    <span class="keyword">int</span> retval, i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  (取 max_fd 并检查 fds 合法性，非法则直接返回错误码)</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    retval = max_select_fd(n, fds);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    n = retval;</span><br><span class="line"></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    wait = &amp;table.pt;</span><br><span class="line">    <span class="keyword">if</span> (!*timeout)</span><br><span class="line">        wait = <span class="literal">NULL</span>;</span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最外层的死循环，重复着：遍历 fd 检查是否有事件就绪，睡眠等待事件发生</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">        <span class="keyword">long</span> __timeout;</span><br><span class="line"></span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">        inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 fd set 的实现做了些遍历的优化，跳过一些完全不需要关心的 fd</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, <span class="built_in">bit</span> = <span class="number">1</span>, mask, j;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">            in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">            all_bits = in | out | ex;</span><br><span class="line">            <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">                i += __NFDBITS;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 和上面一层循环一起，其实是在遍历 fds 上需要观察的 fd</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, <span class="built_in">bit</span> &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> fput_needed;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">bit</span> &amp; all_bits))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                file = fget_light(i, &amp;fput_needed);</span><br><span class="line">                <span class="keyword">if</span> (file) &#123;</span><br><span class="line">                    f_op = file-&gt;f_op;</span><br><span class="line">                    mask = DEFAULT_POLLMASK;</span><br><span class="line">                    <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll)</span><br><span class="line">                        mask = (*f_op-&gt;poll)(file, retval ? <span class="literal">NULL</span> : wait);</span><br><span class="line">                    fput_light(file, fput_needed);</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                        res_in |= <span class="built_in">bit</span>;</span><br><span class="line">                        retval++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                        res_out |= <span class="built_in">bit</span>;</span><br><span class="line">                        retval++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">                        res_ex |= <span class="built_in">bit</span>;</span><br><span class="line">                        retval++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cond_resched();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res_in)</span><br><span class="line">                *rinp = res_in;</span><br><span class="line">            <span class="keyword">if</span> (res_out)</span><br><span class="line">                *routp = res_out;</span><br><span class="line">            <span class="keyword">if</span> (res_ex)</span><br><span class="line">                *rexp = res_ex;</span><br><span class="line">        &#125;</span><br><span class="line">        wait = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 已经有事件发生，或者超时，或者产生了 signal，离开死循环</span></span><br><span class="line">        <span class="keyword">if</span> (retval || !*timeout || signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(table.error) &#123;</span><br><span class="line">            retval = table.error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Wait indefinitely */</span></span><br><span class="line">            __timeout = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(*timeout &gt;= (s64)MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">/* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */</span></span><br><span class="line">            __timeout = MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>;</span><br><span class="line">            *timeout -= __timeout;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __timeout = *timeout;</span><br><span class="line">            *timeout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        __timeout = schedule_timeout(__timeout);</span><br><span class="line">        <span class="keyword">if</span> (*timeout &gt;= <span class="number">0</span>)</span><br><span class="line">            *timeout += __timeout;</span><br><span class="line">    &#125;</span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单介绍一下，先取 fds 的最大 fd，并检查一下 fds 是不是合法，不合法先返回。然后初始化了 poll_wqueues 和 poll_table，其中 poll_table 是供 vfs 的 poll 接口使用的参数，poll_wqueues 是 select 对 poll_table 的包装（用来实现自己的 poll 逻辑）。</p>
<p>接着是 do_select 主体部分，可以看到是一个巨大的循环。<br>最外层的 for(;;) 是死循环，做的事情是</p>
<ol>
<li>设置当前进程 为 TASK_INTERRUPTIBLE 状态</li>
<li>遍历所有选中的 fd，查看是否已经有事件发生（里面的两重 for 循环其实是在 fds 上遍历 fd）</li>
<li>尝试睡眠并等待事件的发生（会维护睡眠时间不超过 timeout）</li>
</ol>
<p>剩下的问题：</p>
<ol>
<li>do_select 是怎么等待事件的发生的，或者说事件发生的时候，是怎么通知到 do_select 的</li>
<li>poll_wqueues 起了什么作用</li>
<li><code>mask = (*f_op-&gt;poll)(file, retval ? NULL : wait);</code> 做了什么 （vfs 的 poll 机制）</li>
</ol>
<h2 id="poll-机制，以-tcp-poll-和-select-为例"><a href="#poll-机制，以-tcp-poll-和-select-为例" class="headerlink" title="poll 机制，以 tcp_poll 和 select 为例"></a>poll 机制，以 tcp_poll 和 select 为例</h2><p>f_op-&gt;poll 会找到对应 vfs 对象的 poll 函数，下面以 tcp socket 为例进行讲解。sock_poll 是 socket 在 vfs 的 fops 封装，其实就是调用了 sock 的 poll 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sock_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      We can't return errors to poll, so it's either yes or no.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    sock = file-&gt;private_data;</span><br><span class="line">    <span class="keyword">return</span> sock-&gt;ops-&gt;poll(file, sock, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应 tcp 协议的 ops-&gt;poll 是 tcp_poll，这是初始化的时候设置到 sock-&gt;ops 上的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Wait for a TCP event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Note that we don't need to lock the socket, as the upper poll layers</span></span><br><span class="line"><span class="comment"> *	take care of normal races (between the test and the event) and we don't</span></span><br><span class="line"><span class="comment"> *	go look at any of the socket buffers directly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"></span><br><span class="line">    poll_wait(file, sk-&gt;sk_sleep, wait);</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN)</span><br><span class="line">        <span class="keyword">return</span> inet_csk_listen_poll(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Socket is not locked. We are protected from async events</span></span><br><span class="line"><span class="comment">	   by poll logic and correct handling of state changes</span></span><br><span class="line"><span class="comment">	   made by another threads is impossible in any case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">    mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_err)</span><br><span class="line">        mask = POLLERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * POLLHUP is certainly not done right. But poll() doesn't</span></span><br><span class="line"><span class="comment">	 * have a notion of HUP in just one direction, and for a</span></span><br><span class="line"><span class="comment">	 * socket the read side is more interesting.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Some poll() documentation says that POLLHUP is incompatible</span></span><br><span class="line"><span class="comment">	 * with the POLLOUT/POLLWR flags, so somebody should check this</span></span><br><span class="line"><span class="comment">	 * all. But careful, it tends to be safer to return too many</span></span><br><span class="line"><span class="comment">	 * bits than too few, and you can easily break real applications</span></span><br><span class="line"><span class="comment">	 * if you don't tell them that something has hung up!</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Check-me.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Check number 1. POLLHUP is _UNMASKABLE_ event (see UNIX98 and</span></span><br><span class="line"><span class="comment">	 * our fs/select.c). It means that after we received EOF,</span></span><br><span class="line"><span class="comment">	 * poll always returns immediately, making impossible poll() on write()</span></span><br><span class="line"><span class="comment">	 * in state CLOSE_WAIT. One solution is evident --- to set POLLHUP</span></span><br><span class="line"><span class="comment">	 * if and only if shutdown has been made in both directions.</span></span><br><span class="line"><span class="comment">	 * Actually, it is interesting to look how Solaris and DUX</span></span><br><span class="line"><span class="comment">	 * solve this dilemma. I would prefer, if PULLHUP were maskable,</span></span><br><span class="line"><span class="comment">	 * then we could set it on SND_SHUTDOWN. BTW examples given</span></span><br><span class="line"><span class="comment">	 * in Stevens' books assume exactly this behaviour, it explains</span></span><br><span class="line"><span class="comment">	 * why PULLHUP is incompatible with POLLOUT.	--ANK</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * NOTE. Check for TCP_CLOSE is added. The goal is to prevent</span></span><br><span class="line"><span class="comment">	 * blocking on fresh not-connected or disconnected socket. --ANK</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_shutdown == SHUTDOWN_MASK || sk-&gt;sk_state == TCP_CLOSE)</span><br><span class="line">        mask |= POLLHUP;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)</span><br><span class="line">        mask |= POLLIN | POLLRDNORM | POLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Connected? */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">        <span class="comment">/* Potential race condition. If read of tp below will</span></span><br><span class="line"><span class="comment">		 * escape above sk-&gt;sk_state, we can be illegally awaken</span></span><br><span class="line"><span class="comment">		 * in SYN_* states. */</span></span><br><span class="line">        <span class="keyword">if</span> ((tp-&gt;rcv_nxt != tp-&gt;copied_seq) &amp;&amp;</span><br><span class="line">            (tp-&gt;urg_seq != tp-&gt;copied_seq ||</span><br><span class="line">             tp-&gt;rcv_nxt != tp-&gt;copied_seq + <span class="number">1</span> ||</span><br><span class="line">             sock_flag(sk, SOCK_URGINLINE) || !tp-&gt;urg_data))</span><br><span class="line">            mask |= POLLIN | POLLRDNORM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sk_stream_wspace(sk) &gt;= sk_stream_min_wspace(sk)) &#123;</span><br><span class="line">                mask |= POLLOUT | POLLWRNORM;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">/* send SIGIO later */</span></span><br><span class="line">                set_bit(SOCK_ASYNC_NOSPACE,</span><br><span class="line">                    &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line">                set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Race breaker. If space is freed after</span></span><br><span class="line"><span class="comment">				 * wspace test but before the flags are set,</span></span><br><span class="line"><span class="comment">				 * IO signal will be lost.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">                <span class="keyword">if</span> (sk_stream_wspace(sk) &gt;= sk_stream_min_wspace(sk))</span><br><span class="line">                    mask |= POLLOUT | POLLWRNORM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;urg_data &amp; TCP_URG_VALID)</span><br><span class="line">            mask |= POLLPRI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到 tcp_poll 首先执行了 <code>poll_wait(file, sk-&gt;sk_sleep, wait);</code>，这里的 wait 是 do_select 传入的 poll_table* 结构。后面的逻辑是在检查当前 tcp 连接的状态，并查看缓冲区的读写状态来确定是否产生了新的可读 / 可写事件，拼到 mask 里返回，do_select 就是读这个返回值来得知是否发生了事件。</p>
<p>跟着看一下 poll_table 和 poll_wait，poll_wait 只是调用了 p-&gt;qproc。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/poll.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>又是一个回调，这里的 p 是 do_select 初始化好并传入的，最终又回调了 p-&gt;qproc。<br>poll_table 的结构，里面只有 qproc 这一个回调函数的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/poll.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * structures and helpers for f_op-&gt;poll implementations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">    poll_queue_proc qproc;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure></p>
<p>select 对 poll_table 做了包装，对应结构 poll_wqueues：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/poll.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structures and helpers for sys_poll/sys_poll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> &#123;</span></span><br><span class="line">    poll_table pt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> * <span class="title">table</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> inline_index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">inline_entries</span>[<span class="title">N_INLINE_POLL_ENTRIES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>do_select 在 poll_initwait 里是怎么初始化的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_poll_funcptr</span><span class="params">(poll_table *pt, poll_queue_proc qproc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pt-&gt;qproc = qproc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_initwait</span><span class="params">(struct poll_wqueues *pwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);</span><br><span class="line">    pwq-&gt;error = <span class="number">0</span>;</span><br><span class="line">    pwq-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">    pwq-&gt;inline_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>__pollwait 的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new entry */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pollwait(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address,</span><br><span class="line">                poll_table *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span> = <span class="title">poll_get_entry</span>(<span class="title">p</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (!entry)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    get_file(filp);</span><br><span class="line">    entry-&gt;filp = filp;</span><br><span class="line">    entry-&gt;wait_address = wait_address;</span><br><span class="line">    init_waitqueue_entry(&amp;entry-&gt;wait, current);</span><br><span class="line">    add_wait_queue(wait_address, &amp;entry-&gt;wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是挺乱的，以 tcp_poll 和 do_select 为例，总结一下和 poll 相关的执行流（只考虑通常情况）：</p>
<ol>
<li>do_select 初始化时，调用 poll_initwait 初始化 poll_wqueues(poll_table)，把 qproc 设置为 __pollwait</li>
<li>do_select 遍历 fd 时，调用 <code>(*f_op-&gt;poll)(file, retval ? NULL : wait);</code> ，这会调用 tcp_poll，传入的 wait 是 poll_wqueues(poll_table)</li>
<li>tcp_poll 里会调用 <code>poll_wait(file, sk-&gt;sk_sleep, wait);</code></li>
<li>poll_wait 会调用 poll_table 注册的 qproc，即 __pollwait 函数</li>
<li>执行 __pollwait 函数</li>
</ol>
<p>__pollwait 函数可以先看最后两行，初始化等待队列，把当前进程挂到 entry-&gt;wait 上，再把 entry-&gt;wait 挂到 sk-&gt;sk_sleep 这个等待队列上，结束。</p>
<p>如果 do_select 遍历的 fds 里所有 fd 都没有已发生的事件，那么f_op-&gt;poll 的调用其实就是在各个 fd 上均执行了 __pollwait，把当前进程挂到了各个 fd 实现的等待队列（只看 tcp socket 的话，对应的是 sk-&gt;sk_sleep。遍历完成后，do_select 检查是否有 signal，或者 timeout 到了，如果都没有，就会陷入睡眠。</p>
<p>睡眠自然是等待唤醒，后面的逻辑也很直观，既然把当前进程挂到了对应 tcp 连接的等待队列上，那么唤醒的部分一定是由 tcp 连接可读 / 可写的时候执行。事实也正是如此，下面以可读为例。</p>
<p>数据包到达网卡，会经过内核网络协议栈，最终到达对应的 tcp 连接进行处理（ tcp_v4_rcv -&gt; tcp_v4_do_rcv ）。对于处于 ESTABLISHED 状态的连接，如果产生新的可读分组，那么会调用 sk-&gt;sk_data_ready。而 sock_init_data 初始化 sock 时会把 sk_data_ready 指向的函数设置为 sock_def_readable。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sock_def_readable</span><span class="params">(struct sock *sk, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read_lock(&amp;sk-&gt;sk_callback_lock);</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_sleep &amp;&amp; waitqueue_active(sk-&gt;sk_sleep))</span><br><span class="line">        wake_up_interruptible(sk-&gt;sk_sleep);</span><br><span class="line">    sk_wake_async(sk,<span class="number">1</span>,POLL_IN);</span><br><span class="line">    read_unlock(&amp;sk-&gt;sk_callback_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也很好懂了，如果 sk_sleep 这个等待队列上有阻塞的进程，那么唤醒它（也就是前面在 do_select 遍历完 fd 之后陷入睡眠的进程）。这个进程被调度之后会重新进入 for(;;) 循环，开启新一轮的 fds 遍历，此时它能够在这个 tcp 连接对应的 fd 上 poll 到事件，从而离开循环，返回到用户态。</p>
<h1 id="epoll-实现分析"><a href="#epoll-实现分析" class="headerlink" title="epoll 实现分析"></a>epoll 实现分析</h1><p>epoll 提供给 tcp_poll 的 poll_table 产生了变化，它不再是直接把 current 挂到 sk_sleep 上并用 default_wakeup 唤醒 task，而是在 sk_sleep 上注册 wakeup_func 为 ep_poll_callback。</p>
<p>epoll_wait 时也不像 poll 一样，遍历 fds 并对每个 fd 进行 poll。epoll_wait 的 for(;;) 循环在等待 rdllist 非空。下面摘一点代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protect the this structure access */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">	 * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">	 * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">	 * code and the ctl operations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a single linked list that chains all the "struct epitem" that</span></span><br><span class="line"><span class="comment">	 * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment">	 * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>epoll_create 会创建 eventpoll 数据结构，相当于这个 epoll file 的内部实现数据结构。对于唤醒和等待的机制，需要关注 wq, rdllist。wq 是调用 epoll_wait 的 task 阻塞的 wait queue，rdllist 是一个链表，维护了发生事件的 epitem。epitem 是内核对添加到 epoll 的 fd 的封装，比如插入到红黑树，插入到 wait queue 都会依赖这个结构。</p>
<p>下面看看 epoll_wait 的 for(;;) 主循环（ ep_poll 函数）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We don't have any available event to return to the caller.</span></span><br><span class="line"><span class="comment">		 * We need to sleep here, and we will be wake up by</span></span><br><span class="line"><span class="comment">		 * ep_poll_callback() when events will become available.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">        wait.flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">        __add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We don't want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment">			 * a wakeup in between. That's why we set the task state</span></span><br><span class="line"><span class="comment">			 * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 ep_poll 的主循环是在等待 rdllist 非空。大致的流程就是 ep_insert 的时候 poll 了 fd，在文件的 wait queue 上注册了 callback，当文件产生 POLLIN POLLOUT 之类的事件时，会调用 callback 把 epitem 插入到 rdllist 并唤醒阻塞在 ep-&gt;wq 上的 task。</p>
<p>在 ep_insert 的时候，是把 ep_ptable_queue_proc 注册到 epq.pt 这个 poll_table 上，供特定文件的 poll 函数执行回调（执行 poll_wait）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_insert</span><span class="params">(struct eventpoll *ep, struct epoll_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">		     struct file *tfile, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">....</span><br><span class="line"><span class="comment">/* Initialize the poll table using the queue callback */</span></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attach the item to the poll hooks and get current event bits.</span></span><br><span class="line"><span class="comment">	 * We can safely use the file* here because its usage count has</span></span><br><span class="line"><span class="comment">	 * been increased by the caller of this function. Note that after</span></span><br><span class="line"><span class="comment">	 * this operation completes, the poll callback can start hitting</span></span><br><span class="line"><span class="comment">	 * the new item.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面看 ep_ptable_queue_proc。不像 poll, select 提供的 __pollwait，直接把 current 注册到文件关联的等待队列（如 sk_sleep ）上，然后等待设备可读写的时候唤醒 task。ep_ptable_queue_proc 是往文件的等待队列上注册了一个回调 ep_poll_callback，可读写的时候是调用 ep_poll_callback，而不是直接唤醒 task。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the callback that is used to add our wait queue to the</span></span><br><span class="line"><span class="comment"> * target file wakeup lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params">				 poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_epqueue</span>(<span class="title">pt</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">        epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看 ep_ptable_queue_proc。不像 poll, select 提供的 __pollwait，直接把 current 注册到文件关联的等待队列（如 sk_sleep ）上，然后等待设备可读写的时候唤醒 task。ep_ptable_queue_proc 是往文件的等待队列上注册了一个回调 ep_poll_callback，可读写的时候是调用 ep_poll_callback，而不是直接唤醒 task。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the callback that is passed to the wait queue wakeup</span></span><br><span class="line"><span class="comment"> * machanism. It is called by the stored file descriptors when they</span></span><br><span class="line"><span class="comment"> * have events to report.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* If this file is already in the ready list we exit soon */</span></span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        <span class="keyword">goto</span> is_linked;</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">is_linked:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()</span></span><br><span class="line"><span class="comment">	 * wait list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        __wake_up_locked(&amp;ep-&gt;wq, TASK_UNINTERRUPTIBLE |</span><br><span class="line">                 TASK_INTERRUPTIBLE);</span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，并不是唤醒了 ep-&gt;wq 上阻塞的 task，那个 task 就会从 ep_poll 返回的，返回前还得再 poll fd，以确保 1. 发生的事件确实是感兴趣的事件，2. 当时发生的事件此时仍然有效。（就像 poll/select 的主循环里，会不断对 fd poll 来检查有效性，避免虚假唤醒）<br>这是在 ep_poll 里进行重试做到的。看 ep_poll 可以发现，for 循环上面有个 retry。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">		   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res, eavail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">long</span> jtimeout;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Calculate the timeout by checking for the "infinite" value ( -1 )</span></span><br><span class="line"><span class="comment">	 * and the overflow condition. The passed timeout is in milliseconds,</span></span><br><span class="line"><span class="comment">	 * that why (t * HZ) / 1000.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to transfer events to user space. In case we get 0 events and</span></span><br><span class="line"><span class="comment">	 * there's still timeout left over, we go trying again in search of</span></span><br><span class="line"><span class="comment">	 * more luck.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后这个注释就讲的很清楚了，ep_send_events 会检查事件并发送到用户态，如果实际上没有发生，且还有 timeout，那就 retry。<br>ep_send_events 会遍历 rdllist 里的 epitem，对每个 epi 做的事情：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Get the ready file event set. We can safely use the file</span></span><br><span class="line"><span class="comment">	* because we are holding the "mtx" and this will guarantee</span></span><br><span class="line"><span class="comment">	* that both the file and the item will not vanish.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="literal">NULL</span>);</span><br><span class="line">revents &amp;= epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Is the event mask intersect the caller-requested one,</span></span><br><span class="line"><span class="comment">	* deliver the event to userspace. Again, we are holding</span></span><br><span class="line"><span class="comment">	* "mtx", so no operations coming from userspace can change</span></span><br><span class="line"><span class="comment">	* the item.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="keyword">if</span> (revents) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__put_user(revents,</span><br><span class="line">                &amp;events[eventcnt].events) ||</span><br><span class="line">        __put_user(epi-&gt;event.data,</span><br><span class="line">                &amp;events[eventcnt].data))</span><br><span class="line">        <span class="keyword">goto</span> errxit;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">        epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">    eventcnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	* At this point, noone can insert into ep-&gt;rdllist besides</span></span><br><span class="line"><span class="comment">	* us. The epoll_ctl() callers are locked out by us holding</span></span><br><span class="line"><span class="comment">	* "mtx" and the poll callback will queue them in ep-&gt;ovflist.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET) &amp;&amp;</span><br><span class="line">    (revents &amp; epi-&gt;event.events))</span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br></pre></td></tr></table></figure></p>
<p>首先 poll fd，检查一下此时真实发生的且感兴趣的事件（两种情况，一种是发生了事件但并不感兴趣，另一种是当时发生了事件但此时已经没有事件）。如果发生了感兴趣的事件，那么拷贝到用户态，并且 eventcnt++，表示可以从 ep_poll (即 epoll_wait ) 返回了。最后再检查一下 epi 是不是 EPOLLET 的，如果不是 ET，并且发生了感兴趣事件，那么把 epi 重新插入到 rdllist 里。言外之意，如果是 LT 模式，一个事件拷贝到用户态后，还会把 epi 插回 rdllist，下次 epoll_wait 还会残留在 rdllist 里，直接进行 poll fd 的检查（即是在这之间，没有新的数据在这个 tcp 连接上到达）。如果是 ET 模式，一个事件拷贝到用户态后，会从 rdllist 里真的删除掉，下次还想在这上面检测到事件，只有等这个 tcp 连接上真的有数据可读或者可写（注意哦，可读或可写都会导致 ep_poll_callback 被调用，因为在 epoll 的通常 wakeup 机制里，是没法区分事件类型的）。</p>
<p>看清这个实现就可以回答一些无聊的实现细节问题…<br>如果一个 tcp 连接上此时有 500 字节可读，正在对外写 400 字节数据，此时有一个 epoll 开始监听这个 tcp socket，ET 模式，对读感兴趣。因为在 ep_insert 的时候会 poll fd，所以对应 epi 会直接进入 rdllist，epoll_wait 的时候可以向用户态返回这个 fd 可读。然后用户态读了 200 字节，缓冲区还剩 300 字节，但 tcp 连接上一直没有新的数据到达，所以不会调用到 sock_def_readble，产生 POLLIN 事件。所以用户态再次 epoll_wait 是不会收到新的可读事件的。</p>
<p>（在低版本内核）但是当 400 字节数据写完的时候，会执行 sk_write_space (sk_write_space 和 tcp socket 产生 POLLOUT 会在后文单独讲)，从而产生 POLLOUT 事件，这会调用 ep_poll_callback 把 epi 插入到 rdllist。那么在 ep_send_events 的时候 poll fd 就会发现此时这个 fd 有感兴趣的 POLLIN 事件，从而向用户态返回这个事件。<br>（注意 2.6.30 以上有在唤醒的时候区分了事件，所以并不会这样，见 <a href="https://github.com/torvalds/linux/commit/2dfa4eeab0fc7e8633974f2770945311b31eedf6）。" target="_blank" rel="noopener">https://github.com/torvalds/linux/commit/2dfa4eeab0fc7e8633974f2770945311b31eedf6）。</a></p>
<h1 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h1><h2 id="tcp-发送-POLLIN-POLLOUT-的时机"><a href="#tcp-发送-POLLIN-POLLOUT-的时机" class="headerlink" title="tcp 发送 POLLIN/POLLOUT 的时机"></a>tcp 发送 POLLIN/POLLOUT 的时机</h2><p>tcp_poll 是直接 poll fd 的时候执行的函数，里面可以看到 tcp socket 对可读/可写的定义，比如处于 LISTEN 状态的 tcp 连接可读的定义，处于 ESTABLISHED 状态的定义。另一方面则是随着网络数据的收发实时产生 POLLIN/POLLOUT （即从 sk_sleep 执行 wakeup）。</p>
<p>对于已经建立的 tcp 连接，在收到对端数据的时候会产生 POLLIN。复读一遍前文：数据包到达网卡，会经过内核网络协议栈，最终到达对应的 tcp 连接进行处理（ tcp_v4_rcv -&gt; tcp_v4_do_rcv ）。对于处于 ESTABLISHED 状态的连接，如果产生新的可读分组，那么会调用 sk-&gt;sk_data_ready。而 sock_init_data 初始化 sock 时会把 sk_data_ready 指向的函数设置为 sock_def_readable。</p>
<p>POLLOUT 会绕一点，因为 tcp 连接可写这件事情不像可读那么直观地定义。在 sock_def_readable 的附近有一个函数 sock_def_write_space。sock_init_data 的时候会把 sk-&gt;sk_write_space 初始化为 sock_def_write_space。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sock_def_write_space</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> *<span class="title">wq</span>;</span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do not wake up a writer until he can make "significant"</span></span><br><span class="line"><span class="comment">	 * progress.  --DaveM</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> ((refcount_read(&amp;sk-&gt;sk_wmem_alloc) &lt;&lt; <span class="number">1</span>) &lt;= READ_ONCE(sk-&gt;sk_sndbuf)) &#123;</span><br><span class="line">        wq = rcu_dereference(sk-&gt;sk_wq);</span><br><span class="line">        <span class="keyword">if</span> (skwq_has_sleeper(wq))</span><br><span class="line">            wake_up_interruptible_sync_poll(&amp;wq-&gt;wait, EPOLLOUT |</span><br><span class="line">                        EPOLLWRNORM | EPOLLWRBAND);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Should agree with poll, otherwise some programs break */</span></span><br><span class="line">        <span class="keyword">if</span> (sock_writeable(sk))</span><br><span class="line">            sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sk_write_space 会在这几个地方调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">do_tcp_sendpages</span><span class="params">(struct sock *sk, struct page *page, <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg_locked</span><span class="params">(struct sock *sk, struct msghdr *msg, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Socket option code for TCP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_tcp_setsockopt</span><span class="params">(struct sock *sk, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">sockptr_t</span> optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">case</span> TCP_NOTSENT_LOWAT:</span><br><span class="line">        tp-&gt;notsent_lowat = val;</span><br><span class="line">        sk-&gt;sk_write_space(sk);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前两个函数的用法类似，都是在末尾有这段代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">out_err:</span><br><span class="line">    <span class="comment">/* make sure we wake any epoll edge trigger waiter */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tcp_rtx_and_write_queues_empty(sk) &amp;&amp; err == -EAGAIN)) &#123;</span><br><span class="line">        sk-&gt;sk_write_space(sk);</span><br><span class="line">        tcp_chrono_stop(sk, TCP_CHRONO_SNDBUF_LIMITED);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>即 tcp 写数据结束的时候，检查一下 写队列和重传队列 是不是为空，如果是空的话，发送一次 POLLOUT（通过调用 sk-&gt;sk_write_space）。<br>而 do_tcp_setsockopt 里的用法就不讲了，跟 tcp 协议强相关，看个热闹吧。</p>
<h2 id="select-poll-的一个-patch"><a href="#select-poll-的一个-patch" class="headerlink" title="select/poll 的一个 patch"></a>select/poll 的一个 patch</h2><p><a href="https://github.com/torvalds/linux/commit/5f820f648c92a5ecc771a96b3c29aa6e90013bba" target="_blank" rel="noopener">https://github.com/torvalds/linux/commit/5f820f648c92a5ecc771a96b3c29aa6e90013bba</a><br>用 custom wake up function 代替 default_wake_function，加入一个 trigger 变量来维护事件是否发生过，从而避免主循环在 poll 之后，interruptiable sleep 之前产生的事件通知不到 task。</p>
<h2 id="epoll-的一个-patch"><a href="#epoll-的一个-patch" class="headerlink" title="epoll 的一个 patch"></a>epoll 的一个 patch</h2><p><a href="https://github.com/torvalds/linux/commit/2dfa4eeab0fc7e8633974f2770945311b31eedf6" target="_blank" rel="noopener">https://github.com/torvalds/linux/commit/2dfa4eeab0fc7e8633974f2770945311b31eedf6</a><br>前文提到的 patch，通过 wakeup 的 key 参数告知 ep_poll_callback 发生的事件，减少不必要的唤醒。</p>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>内核实现是复杂、逐渐完善的，早期内核也有各种明显的小问题</p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="https://blog.runc.dev">shengrang</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://blog.runc.dev/2021/12/19/poll-note/">https://blog.runc.dev/2021/12/19/poll-note/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/kernel/">kernel</a>
            <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
            </div>
        
        <nav class="post-nav"><a class="next" href="/2020/02/22/introduction-to-concurrency-programming-2/">
        <span class="next-text nav-default">并发编程基础 - C++原子操作语义和内存模型</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="https://github.com/shengrang" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2022<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">shengrang</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.1"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
