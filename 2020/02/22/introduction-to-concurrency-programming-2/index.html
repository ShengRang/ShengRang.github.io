<!DOCTYPE html>
<html lang="">
  <head><meta charset="UTF-8"/>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="并发编程基础 - C++原子操作语义和内存模型"/><meta name="keywords" content="并发编程, 乌云制作法" /><link rel="alternate" href="/atom.xml" title="乌云制作法"><link rel="shortcut icon" type="image/x-icon" href="/images/lucid5.jpg?v=2.11.1" />
<link rel="canonical" href="https://blog.runc.dev/2020/02/22/introduction-to-concurrency-programming-2/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.1" />

<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>并发编程基础 - C++原子操作语义和内存模型 - 乌云制作法</title>
  <meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">乌云制作法</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">乌云制作法</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">并发编程基础 - C++原子操作语义和内存模型
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-02-22
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic-types"><span class="toc-text">atomic types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Happens-Before-关系"><span class="toc-text">Happens Before 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子操作与-memory-order"><span class="toc-text">原子操作与 memory_order</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Relaxed-ordering"><span class="toc-text">Relaxed ordering</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Release-Acquire-ordering"><span class="toc-text">Release-Acquire ordering</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Release-Consume-ordering"><span class="toc-text">Release-Consume ordering</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sequentially-consistent-ordering"><span class="toc-text">Sequentially-consistent ordering</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最后"><span class="toc-text">最后</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>本篇介绍 C++11 内存模型以及原子操作语义。</p>
<a id="more"></a>
<p><strong>Correct me if I’m wrong.</strong></p>
<p>内存模型为 C++ abstract machine 定义了内存存储的语义。内存模型包含两方面，<em>structural</em> 部分关于元素的布局，<em>concurrency</em> 关于并发。</p>
<p>byte 是内存里的最小单元，定义为连续的 bits. 从 C++14 起，一个 byte 足够容纳 UTF-8 编码单元 (256 个不同值) 和基本执行字符集（96 个字符，要求必为单字节）。和 C 一样，C++ 也支持 8bit 或者更大的字节。C++ 里的所有数据都是由 object 构成的。这个对象不是说你可以写一个继承自 int 的类，或者基础数据类型存在成员函数，这个对象不是 OO 语言里的对象。无论一个对象是什么类型，这个对象都存储在一个或者多个 <strong>内存位置</strong>。可以把内存位置理解为内存地址。注意为了实现 C++，比如实现虚函数用到了虚指针，所以存在一些额外的内存位置，是不希望程序访问的。</p>
<p>内存模型的剩余部分就关于并发，这也是本篇的主要内容。进入正题前讲一点背景，为什么内存模型需要定义并发时的内存操作行为。如果两个线程访问同一个内存位置，存在一个不是原子操作，且至少存在一个进行写操作，并且这两个操作没有一个明确的先后关系，那么这是一种 data race，会导致未定义行为。C/C++ 里发生未定义行为是危险，无保障的。当然了，解决 data race 显然是可以用互斥锁，条件变量之类的同步原语。但是还存在另一种解决方法，就是原子操作。众所周知，原子操作的效果是这个操作的原子性，即这个操作要么没发生，要么已完成，无法观察到这个操作执行了一半的某种不完整状态。但是如前所述，原子操作更大的好处是可以建立起内存操作 <strong>(尤其是非原子操作)</strong> 之间的先发生关系(happens-before)，从而避免 data race。</p>
<h3 id="atomic-types"><a href="#atomic-types" class="headerlink" title="atomic types"></a>atomic types</h3><p>C++ 的标准原子类型在 <code>&lt;atomic&gt;</code> 头文件里。这些 atomic types 的所有操作都是原子的，C++标准定义下也只有这些类型的操作是原子的(显然你可以用 <code>mutex</code> 之类的同步原语自己实现原子性)。原子指的是无法观察到操作执行了一半的不完整状态。举个例子，<code>int x=0;</code> 两个线程分别 <code>x++</code> 1000次，最终 x 大概率是不等于 2000 的，<code>x++</code> 其实会拆成读 <code>x</code>，然后算 <code>x+1</code>，再把结果写会 <code>x</code> 几个操作，可能有两个线程读到同一个 <code>x</code> 值，然后各自算 <code>x+1</code>，最后写会 <code>x+1</code>，这样就少加了一次，因为读到了不完整状态。而使用 <code>std::atomic&lt;int&gt; x = 0;</code>，使用 <code>fetch_add</code> 就能解决这个问题，因为对 <code>int</code> 自增是非原子的，而 <code>std::atomic&lt;int&gt;::fetch_add</code> 是原子的。</p>
<p>注意，atomic types 的原子性是从语言标准层面说的，具体实现可能是基于 CPU 提供的原子操作指令，也可能是基于锁的。通过 <code>is_lock_free()</code> 成员函数可以判断这个原子类型是否是 <strong>lock-free</strong> 的。<code>std::atomic_flag</code> 不提供 <code>is_lock_free()</code>，这个类型就是个布尔类型(注意与 <code>std::atomic_bool</code> 区分)，标准要求这个类型的操作必须实现成 lock-free 的。当然了，大多数平台的内建类型对应的原子类型是 lock-free 的，比如 <code>atomic&lt;int&gt;</code>, <code>atomic&lt;void*&gt;</code> (这不是强制要求)。</p>
<p>标准原子类型是不能进行拷贝和赋值的，它们没有拷贝构造函数和拷贝赋值操作符。但是，它们可以与对应的内建类型进行隐式转换，所以支持从对应内建类型赋值，或者使用对应内建类型进行 <code>load()</code> 和 <code>store()</code>、 <code>exchange()</code>、 <code>compare_exchange_weak()</code> 和 <code>compare_exchange_strong()</code>。它们也支持复合赋值符：+=, -=, *=, |= 等等。当然，这些操作也有功能相同的成员函数所对应：<code>fetch_add()</code>, <code>fetch_or()</code> 等。</p>
<p>初等 <code>std::atomic</code> 模板可用任何满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible" target="_blank" rel="noopener">可复制构造 (CopyConstructible)</a> 及<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">可复制赋值 (CopyAssignable)</a> 的<a href="https://zh.cppreference.com/w/cpp/named_req/TriviallyCopyable" target="_blank" rel="noopener">可平凡复制 (TriviallyCopyable)</a> 类型 T 特化。下列值都得为真：</p>
<ul>
<li><code>std::is_trivially_copyable&lt;T&gt;::value</code></li>
<li><code>std::is_copy_constructible&lt;T&gt;::value</code></li>
<li><code>std::is_move_constructible&lt;T&gt;::value</code></li>
<li><code>std::is_copy_assignable&lt;T&gt;::value</code></li>
<li><code>std::is_move_assignable&lt;T&gt;::value</code></li>
</ul>
<p>大概就是如果你想用 <code>std::atmoic&lt;UserDefineType&gt;</code>，那么这个 <code>UserDefineType</code> 不能自定义拷贝赋值函数，不能有虚基类，虚函数，表现起来就是一个纯数据的结构体。这不重要啦，因为这样的 atomic 类型未必是 lock-free 的。</p>
<p>原子类型的每个操作都有一个可选的 <em>memory-ordering</em> 参数，可选项是 <code>std::memory_order</code> 枚举，默认值是最强的内存序 <code>std::memory_order_seq_cst</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> memory_order &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><br>原子操作可以分为下面几种：</p>
<ol>
<li><em>Store</em> 操作，可以选择 <code>memory_order_relaxed</code>, <code>memory_order_release</code>, <code>memory_order_seq_cst</code></li>
<li><em>Load</em> 操作，可以选择 <code>memory_order_relaxed</code>, <code>memory_order_consume</code>, <code>memory_order_acquire</code>, <code>memory_order_seq_cst</code></li>
<li><em>Read-modify-write</em> 操作，可以选择 <code>memory_order_relaxed</code>, <code>memory_order_consume</code>, <code>memory_order_acquire</code>, <code>memory_order_release</code>, <code>memory_order_acq_rel</code>, <code>memory_order_seq_cst</code></li>
</ol>
<p>这里不展开介绍各个 atomic 类型的每个操作的用法，这部分内容可以查 cppreference 之类的文档。原因之前也讲过了，利用原子操作可以避免原子变量本身处于操作半完成的状态，但是本文更关注原子操作在并发编程中建立同步关系的应用，不是所有问题都可以像前面一样只利用简单的原子操作解决。学会利用 <code>std::atomic</code> 上的原子操作搭配合适的 memory_order 进行同步 (跨线程建立原子变量的同步关系，从而对非原子的操作建立同步关系)，可以在互斥锁之外增加并发编程的可选项。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>为了确保文章质量，我会尽可能避免写出错误的观点（如果我错了请纠正我）。这方面的内容比较复杂，在学的时候也感到比较困扰。网上的帖子、书上可能会在一些地方讲的有出入或者不够清晰，所以专门写一节 <strong>基本概念</strong>，内容尽量按优先级来自 c++ 标准，cppreference，C++ Concurrency in Action。我会先给出英文和出处，然后用中文做一些解释。</p>
<p>首先建议已经了解离散数学里的偏序关系和全序关系。</p>
<ul>
<li>Two expression evaluations conflict if one of them modifies a memory location (1.7) and the other one accesses or modifies the same memory location. [c++ standard 1.10]</li>
<li>The execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in <strong>undefined behavior</strong>. [c++ standard 1.10]</li>
<li>If one evaluation modifies a memory location, and the other reads or modifies the same memory location, and if at least one of the evaluations is not an atomic operation, the behavior of the program is undefined (the program has a data race) unless there exists a happens-before relationship between these two evaluations.[cppreference]</li>
</ul>
<blockquote>
<p>上面这三句话定义了 conflict 和 data race。如果两个操作针对同一个 memory location，其中至少一个是写入，那么这俩操作是冲突的。如果至少其中一个是非原子且没有 happens before(后面给出定义，大概就是一个比另一个先发生，学过分布式的应该都知道 lamport 提出的这个概念) 另一个的，那么这个程序是存在 data race 的。任何这种 data race 导致 <strong>undefined behavior</strong>。C++ 14 的 data race 会比这个复杂一点，和 signal handler 有关这里不讨论。</p>
</blockquote>
<ul>
<li>The library defines a number of atomic operations (Clause 29) and operations on mutexes (Clause 30) that are specially identified as synchronization operations. These operations play a special role in making assignments in one thread visible to another. A synchronization operation on one or more memory locations is either a consume operation, an acquire operation, a release operation, or both an acquire and release operation. A synchronization operation without an associated memory location is a fence and can be either an acquire fence, a release fence, or both an acquire and release fence. In addition, there are relaxed atomic operations, which are not synchronization operations, and atomic read-modify-write operations, which have special characteristics.[c++ standard 1.10]</li>
</ul>
<blockquote>
<p>c++ library 定义了一些原子操作和互斥操作，统称 synchronization operations(下面可能简写成 sync op)。这些操作在跨线程同步的时候做可见性保证。synchronization operation 分成这几种：consume operation, acquire operation, release operation, both an acquire and release operation. 没有关联到特定 memory location 的 sync op 是 fence，can be either an acquire fence, a release fence, or both an acquire and release fence。另外，relaxed atomic operations 不是 sync op，原子 read-modify-write 操作有一些特殊性质。这段话说了什么是 sync op，以及 sync op 的几种类型，这个分类在下面会用到。</p>
</blockquote>
<ul>
<li>All modifications to a particular atomic object M occur in some particular total order, called the modification order of M. If A and B are modifications of an atomic object M and A happens before (as defined below) B, then A shall precede B in the modification order of M, which is defined below.[ Note: This states that the modification orders must respect the “happens before” relationship. — end note ] [ Note: There is a separate order for each atomic object. There is no requirement that these can be combined into a single total order for all objects. In general this will be impossible since different threads may observe modifications to different objects in inconsistent orders. — end note ][c++ standard 1.10]</li>
<li>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.[cppreference]</li>
<li>Every object in a C++ program has a modification order composed of all the writes to that object from all threads in the program, starting with the object’s initialization. In most cases this order will vary between runs, but in any given execution of the program all threads in the system must agree on the order. If the object in question isn’t one of the atomic types described in section 5.2, you’re responsible for making certain that there’s sufficient synchronization to ensure that threads agree on the modification order of each variable. If different threads see distinct sequences of values for a single variable, you have a data race and undefined behavior (see section 5.1.2). If you do use atomic operations, the compiler is responsible for ensuring that the necessary synchronization is in place.[C++ Concurrency in Action 5.1.3]</li>
</ul>
<blockquote>
<p>上面前两段话说明了原子对象的修改顺序。每个原子对象 M 都有一个关于自己的修改操作的顺序，这是一个单独的全序，叫做 modification order。意思就是对于一个特定的原子对象 M，所有对他的写入，最终在 M 看来都是按照 modification order 的顺序逐一生效的。如果 A 和 B 都是对 M 的修改，并且 A happens before B，那么在 M 的修改顺序里，A 应该在 B 的前面。最后一段意思大概是说每个对象 (包括非原子) 都有一个 modification order，原子对象确保所有线程都看到这个 modification order，达成共识。而非原子对象天然没有这个保证，如果不同线程没有达成共识，可能不同线程看到不一样的 order，那就产生了 data race，ub 了，所以你就得通过合适的同步确保所有线程达成共识。</p>
</blockquote>
<p>A <em>visible side effect</em> A on a scalar object or bit-field M with respect to a value computation B of M satisfies the conditions:</p>
<ol>
<li>A happens before B and</li>
<li>there is no other side effect X to M such that A happens before X and X happens before B.<br>The value of a non-atomic scalar object or bit-field M, as determined by evaluation B, shall be the value stored by the visible side effect A. [ Note: If there is ambiguity about which side effect to a non-atomic object or bit-field is visible, then the behavior is either unspecified or undefined. — end note ] [ Note: This states that operations on ordinary objects are not visibly reordered. This is not actually detectable without data races, but it is necessary to ensure that data races, as defined below, and with suitable restrictions on the use of atomics, correspond to data races in a simple interleaved (sequentially consistent) execution. — end note ]<br>[c++ standard 1.10]</li>
</ol>
<blockquote>
<p>非形式化地说，读操作 B 读取对象 M，读到的值应该是 happens before 关系中，B 前面离 B 最近的一个写操作 A 对 M 写入的值。因为 hb <strong>是偏序关系而不是全序关系</strong>，所以这样的 A 未必是唯一的，此时行为是 unspecified 或者 undefined 的。（严格地按照C++ 11标准来说，由于携带依赖和依赖先序的存在，hb 并不总是具有传递性，所以不是严格的偏序）</p>
</blockquote>
<p>TODO: visible sequence of side-effects</p>
<h3 id="Happens-Before-关系"><a href="#Happens-Before-关系" class="headerlink" title="Happens Before 关系"></a>Happens Before 关系</h3><p>前文说的一些概念，包括很多对内存模型的解释，都会频繁地提到 <strong>Happens Before</strong>。这个 happens before 是分布式领域专家（图灵奖得主、LaTeX初代作者） Lamport 老爷子在讨论分布式系统时钟的著名论文 <em>Time, Clocks, and the Ordering of Events in a Distributed System</em> 提出的，用潜在的因果关系来对分布式系统中的事件构造一种偏序关系，这里不想扯太多分布式的内容（分布式的话题很大，很值得讨论）。在 C++ 标准，Java Memory Model 里，都会借用 Happens Before 的概念，对多线程的执行中的每个操作（把线程看做分布式系统中不同节点的进程）构建 happens before 关系，可能具体标准有细节偏差，但大概的思路是，如果 A happens before B (后面可能会简写为 <code>hb(A, B)</code>)，那么写入操作 A 的效应应该对读取操作 B 可见（当然如果有 <code>hb(A,C) &amp;&amp; hb(C, B)</code>，那么读取 B 应该看见写入 C 的效应，A 被 C 覆盖）。</p>
<p>这一节会讲解什么是 happens before 关系。直观地留一个印象，非形式化地描述，happens before 为多线程程序里的操作建立一个谁先发生的关系，happens before 由两部分构成。一部分是线程内程序执行的先后顺序，也就是不考虑并发只有单线程的时候代码执行的顺序，这个顺序很直观。另一部分是跨线程建立的线程间同步关系，比如线程 A 解锁 mutex，线程 B 对 mutex 获得了锁，显然得 A <strong>先</strong>解锁 mutex，才能<strong>后</strong> B 获得锁，比如线程 A 对某个原子变量写入值 233，线程 B 从这个原子变量读到了值 233，那么直观上应该是 A <strong>先</strong>写入，B 才能<strong>后</strong>读到。直观地看，这两部分的先后关系加上传递性，就是 happens before 关系。</p>
<p>Within the same thread, evaluation A may be sequenced-before evaluation B, as described in <a href="https://en.cppreference.com/w/cpp/language/eval_order" target="_blank" rel="noopener">evaluation order</a>. [cppreference]<br>首先从单线程的情况开始，C++ 标准在单线程里定义了 sequenced-before 的关系，大概描述了单线程代码的先后顺序，直观来说就是代码执行的顺序，比如代码 <code>x=5; y=6;</code> 可以说 <code>x=5;</code> sequenced-before <code>y=6;</code>。但是在细节上有很多坑，比如说 <code>i = i++ + i++;</code> 这种代码是有 ub 的，<code>f(a(), b(), c());</code> 这个代码里 a, b, c 的调用顺序是没有谁先谁后的规定的，这方面的细枝末节不是本文的重点，请自行查看标准或者cppreference。</p>
<p>Certain library calls <em>synchronize with</em> other library calls performed by another thread. For example, an atomic store-release synchronizes with a load-acquire that takes its value from the store (29.3). [ Note: Except in the specified cases, reading a later value does not necessarily ensure visibility as described below. Such a requirement would sometimes interfere with eﬃcient implementation. — end note ] [ Note: The specifications of the synchronization operations define when one reads the value written by another. For atomic objects, the definition is clear. All operations on a given mutex occur in a single total order. Each mutex acquisition “reads the value written” by the last mutex release. — end note ] [c++ standard 1.10]<br>接着是 synchronizes-with 关系，C++ 标准的给定义是，一些特定的库调用 synchronizes-with 另一个线程的特定库调用。比如原子的 store-release 操作 synchronizes-with 另一个线程里看到了这个 store 写入值的 load-acquire 操作。</p>
<p>可以发现，<em>sequenced-before</em> 关系描述了线程内（intra-thread）的先后关系，<em>synchronizes-with</em> 关系描述了跨线程（inter-thread）的先后关系。我们已经接近 <em>happens before</em> 关系的定义，然而完整的标准还包括 <em>carries a depency</em> 和 <em>dependency-ordered before</em> 关系。这俩的存在破坏了 hb 的传递性，从而 hb 不是严格的偏序关系。而且按照 cppreference 的说法，这种精细的依赖分析截至2015年还没有编译器能做到，consume operation 会提升为 acquire operation，从 c++ 17 开始，The specification of release-consume ordering is being revised, and the use of memory_order_consume is temporarily discouraged. 这有点烦。但是为了完整性，我接下来会讲解这两个关系，然后开始对 <em>happens before</em> 关系进行定义。</p>
<blockquote>
<p>如果觉得头痛可以先选择性忽视这两个关系以及 <em>consume operation</em>，直接跳到 <em>happens before</em> 的定义，并修改 hb 的定义，<strong>暂时认为</strong> <em>inter-thread happens before</em> 就是 <em>synchronizes-with</em>，且 hb 关系具有传递性，跳过的这部分可以回过头再重新看（不看也没事..）。</p>
</blockquote>
<p>An evaluation A <em>carries a dependency</em> to an evaluation B if</p>
<ul>
<li>the value of A is used as an operand of B, unless:<ol>
<li>B is an invocation of any specialization of std::kill_dependency (29.3), or</li>
<li>A is the left operand of a built-in logical AND (&amp;&amp;, see 5.14) or logical OR (||, see 5.15) operator, or</li>
<li>A is the left operand of a conditional (?:, see 5.16) operator, or</li>
<li>A is the left operand of the built-in comma (,) operator (5.18);<br>or</li>
</ol>
</li>
<li>A writes a scalar object or bit-field M, B reads the value written by A from M, and A is sequenced before B, or</li>
<li>for some evaluation X, A carries a dependency to X, and X carries a dependency to B.<br>[ Note: “Carries a dependency to” is a subset of “is sequenced before”, and is similarly strictly intrathread. — end note ] [C++ standard 1.10]<br>A carries a dependency B 直观上的意思就是求值 B 依赖了求值 A，第一条的一些特例是斩断这种依赖（通过 kill_dependency 显式切断，或者由于 &amp;&amp; 的短路逻辑切断等）。第三条让这个关系具有传递性。这个关系可以看做是 sequenced before 关系的子集，因为有些语句没有依赖关系。举个例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p  = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Hello"</span>);     <span class="comment">// 1</span></span><br><span class="line">    data = <span class="number">42</span>;                                      <span class="comment">// 2</span></span><br><span class="line">    ptr.store(p, <span class="built_in">std</span>::memory_order_release);        <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// sequeenced before 关系： 1 --&gt; 2 --&gt; 3</span></span><br><span class="line">    <span class="comment">// carries a dependency 关系：1 --&gt; 3</span></span><br><span class="line">    <span class="comment">// 因为 2 这句话对 data 写入，与 3 无依赖关系，3 读了 p，1 写了 p，所以 1 --&gt; 3.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A release sequence headed by a release operation A on an atomic object M is a maximal contiguous subsequence of side effects in the modification order of M, where the first operation is A, and every subsequent operation</p>
<ul>
<li>is performed by the same thread that performed A, or</li>
<li>is an atomic read-modify-write operation.</li>
</ul>
<p>在 dependency-ordered 的定义中要用到 release sequence 的概念， release sequence 指的是对原子对象 M 的 modification order 里 release 操作 A 后面跟着的最长连续的修改操作，每个操作都满足或者是执行 A 的线程中做的修改操作，或者是一个 read-modify-write 操作。这个 release sequence 在原子操作的 memory_order 里还会用到。</p>
<p>An evaluation A is dependency-ordered before an evaluation B if</p>
<ul>
<li>A performs a release operation on an atomic object M, and, in another thread, B performs a consume operation on M and reads a value written by any side effect in the release sequence headed by A, or</li>
<li>for some evaluation X, A is dependency-ordered before X and X carries a dependency to B.<br>dependency-ordered<br>[ Note: The relation “is dependency-ordered before” is analogous to “synchronizes with”, but uses release/consume in place of release/acquire. — end note ] [c++ standard 1.10]</li>
</ul>
<p><em>dependency-ordered before</em> 关系是一个跨线程(inter-thread)关系，类似于 <em>synchronizes-with</em> 关系，但是把 release/acquire 操作对换成了 release/consume 操作对。</p>
<p>An evaluation A <em>inter-thread happens before</em> an evaluation B if</p>
<ul>
<li>A synchronizes with B, or</li>
<li>A is dependency-ordered before B, or</li>
<li>for some evaluation X<ol>
<li>A synchronizes with X and X is sequenced before B, or</li>
<li>A is sequenced before X and X inter-thread happens before B, or</li>
<li>A inter-thread happens before X and X inter-thread happens before B.</li>
</ol>
</li>
</ul>
<p>[ Note: The “inter-thread happens before” relation describes arbitrary concatenations of “sequenced before”, “synchronizes with” and “dependency-ordered before” relationships, with two exceptions. The first exception is that a concatenation is not permitted to end with “dependency-ordered before” followed by “sequenced before”. The reason for this limitation is that a consume operation participating in a “dependencyordered before” relationship provides ordering only with respect to operations to which this consume operation actually carries a dependency. The reason that this limitation applies only to the end of such a concatenation is that any subsequent release operation will provide the required ordering for a prior consume operation. The second exception is that a concatenation is not permitted to consist entirely of “sequenced before”. The reasons for this limitation are (1) to permit “inter-thread happens before” to be transitively closed and (2) the “happens before” relation, defined below, provides for relationships consisting entirely of “sequenced before”. — end note ] [c++ standard 1.10]</p>
<p>这定义了 inter-thread happens before 关系，大致可以认为是组合了 sequenced before, synchronizes with, dependency-ordered before 关系，但是第三条对细节上做了一些调整。第一个调整让依赖关系更加精细， “dependency-ordered before” 后面跟着 “sequenced before” 是不能传递出 inter-thread happens before 的，因为依赖关系想要更精细一些（carries a dependency 比 sequenced before 精细，刻画了求值之间的依赖），没有依赖的求值不需要可见。</p>
<p>最后，我们终于来到 <em>happens before</em> 关系的定义：<br>An evaluation A happens before an evaluation B if:</p>
<ul>
<li>A is sequenced before B, or</li>
<li>A inter-thread happens before B.</li>
</ul>
<p>The implementation shall ensure that no program execution demonstrates a cycle in the “happens before” relation. [ Note: This cycle would otherwise be possible only through the use of consume operations. — end note ] [c++ standard 1.10]</p>
<p><em>happens before</em> 关系由两部分组成：intra-thread 的 <em>sequenced before</em> 和 inter-thread 的 <em>inter-thread happens before</em>。注意这里并没有给 hb 定义传递性规则。假设 <code>hb(A, B) &amp;&amp; hb(B, C)</code>， 我们可以分情况简单地分析一下：</p>
<ol>
<li>$ sb(A, B) \land sb(B, C) \Rightarrow sb(A, C) \Rightarrow hb(A, C)$</li>
<li>$ sb(A, B) \land ithb(B, C) \Rightarrow ithb(A, C) \Rightarrow hb(A, C) $ </li>
<li>$ ithb(A, B) \land ithb(B, C) \Rightarrow ithb(A, C) \Rightarrow hb(A, C) $</li>
<li>$ ithb(A, B) \land sb(B, C) \Rightarrow \ ? $</li>
</ol>
<p>第四种情况里，如果 A dependency-ordered before B，我们无法得出 <code>ithb(A, C)</code>，所以说 hb 并不满足传递性。</p>
<p>总结一下，这一节通过 intra-thread 和 inter-thread 的先后关系定义，我们得到了对多线程程序每个操作的 happens before 关系。结合基本概念里提到的标准条目，<del>我们已经可以对多线程程序的正确性进行分析。下面我们做一点简单的练习题：</del> 我们可以用 synchronization operation (原子操作，互斥操作等) 建立 inter-thread happens before 关系，从而对跨线程的操作 (尤其是非原子操作) 建立 happens before 关系，通过 happens before 关系的保障，我们可以避免 data race，得到正确同步的代码。接下来讲解原子类型上的原子操作是以什么规则建立 inter-thread happens before 关系的。</p>
<p><img src="算术入门.jpeg" alt="算术入门"></p>
<h3 id="原子操作与-memory-order"><a href="#原子操作与-memory-order" class="headerlink" title="原子操作与 memory_order"></a>原子操作与 memory_order</h3><p>The basic idea is this: a suitably-tagged atomic write operation, W, on a variable, x, synchronizes with a suitably-tagged atomic read operation on x that reads the value stored by either that write, W, or a subsequent atomic write operation on x by the same thread that performed the initial write, W, or a sequence of atomic read-modify-write operations on x (such as fetch_add() or compare_exchange_weak()) by any thread, where the value read by the first thread in the sequence is the value written by W. [C++ Concurrency in Action]</p>
<p>大致思想是，对变量 x 的 suitably-tagged 的原子写操作 W，synchronizes-with 对变量 x 的 suitably-tagged 原子读操作，这个读操作或者读到了 W 写入的值，或者读到 head by W 的 release sequence 里的写入操作的写入值。</p>
<p>原子类型的每个操作都有一个可选的 <em>memory-ordering</em> 参数，可选项是 <code>std::memory_order</code> 枚举，默认值是最强的内存序 <code>std::memory_order_seq_cst</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> memory_order &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure></p>
<p>The enumeration memory_order specifies the detailed regular (non-atomic) memory synchronization order as defined in 1.10 and may provide for operation ordering. Its enumerated values and their meanings are as follows:[c++ standard 29.3 atomics.order]</p>
<ul>
<li>memory_order_relaxed: no operation orders memory.</li>
<li>memory_order_release, memory_order_acq_rel, and memory_order_seq_cst: a store operation performs a release operation on the affected memory location.</li>
<li>memory_order_consume: a load operation performs a consume operation on the affected memory location.</li>
<li>memory_order_acquire, memory_order_acq_rel, and memory_order_seq_cst: a load operation performs an acquire operation on the affected memory location.</li>
</ul>
<p>标准中对 synchronization operation 做了分类：consume operation, acquire operation, release operation, both an acquire and release operation。看名字可以知道 memory_order 的选择大概就对应了 synchronization operation 的分类。memory_order 有 6 个选择，但这些选择是要搭配使用的，实际上有意义的 ordering 有 Relaxed ordering, Release-Acquire ordering, Release-Consume ordering, Sequentially-consistent ordering 这几种。</p>
<h4 id="Relaxed-ordering"><a href="#Relaxed-ordering" class="headerlink" title="Relaxed ordering"></a>Relaxed ordering</h4><p>先从最弱的 memory_order_relaxed 开始。memory_order_relaxed 意味着对同步无贡献，不是 synchronization operation，不建立 inter-thread happens-before 关系。但是注意区分 happens-before 关系和原子对象的 modification order，另外记得 memory_order_relaxed 只是在同步上宽松（弱），这不影响原子操作的原子性。</p>
<p>前面在基本概念没有说 4 条挺重要的对 modification order 的规则，怕放在前面概念太多看的晕。</p>
<ul>
<li>If an operation A that modifies an atomic object M happens before an operation B that modifies M, then A shall be earlier than B in the modification order of M. [ Note: This requirement is known as write-write coherence. — end note ]</li>
<li>If a value computation A of an atomic object M happens before a value computation B of M, and A takes its value from a side effect X on M, then the value computed by B shall either be the value stored by X or the value stored by a side effect Y on M, where Y follows X in the modification order of M. [ Note: This requirement is known as read-read coherence. — end note ]</li>
<li>If a value computation A of an atomic object M happens before an operation B that modifies M, then A shall take its value from a side effect X on M, where X precedes B in the modification order of M. [ Note: This requirement is known as read-write coherence. — end note ]</li>
<li>If a side effect X on an atomic object M happens before a value computation B of M, then the evaluation B shall take its value from X or from a side effect Y that follows X in the modification order of M. [ Note: This requirement is known as write-read coherence. — end note ]</li>
<li>[ Note: The four preceding coherence requirements effectively disallow compiler reordering of atomic operations to a single object, even if both operations are relaxed loads. This effectively makes the cache coherence guarantee provided by most hardware available to C ++ atomic operations. — end note ]<br>[c++ standard 1.10 [intro.multithread]]</li>
</ul>
<p>在 cppreference 里也说了这个规则，摘个中文版的：</p>
<p><strong>修改顺序</strong><br>对任何特定的原子变量的修改，以限定于此一原子变量的单独全序出现。<br>对所有原子操作保证下列四个要求：<br>1) <strong>写写连贯</strong>：若修改某原子对象 M 的求值（写） A 先发生于修改 M 的求值 B ，则 A 在 M 的修改顺序中早出现于 B 。<br>2) <strong>读读连贯</strong>:若某原子对象的值计算（读） A 先发生于 M 上的值计算 B ，且若 A 的值来自 M 上的写入 X ，则 B 的值是 X 所存储的值，或在 M 的修改顺序中后出现于 X 的 M 上副效应 Y 所存储的值。<br>3) <strong>读写连贯</strong>：若某原子对象 M 的值计算（读） A 发生先于 M 上的操作 B （写），则 A 的值来自 M 的修改序列中早出现于 B 的副效应（写） X 。<br>4) <strong>写读连贯</strong>：若原子对象 M 上的副效应（写） X 先发生于 M 的值计算（读） B ，则求值 B 应从 X 或从 M 的修改顺序中后随 X 的副效应 Y 取得其值。</p>
<p>解释一下，这四条规则是对原子对象的 modification order 和对这个原子对象进行的原子操作的 happens-before 的一致性约束。另外注意 modification order 里是没有读操作的。直观来说这个规则就是一种新鲜度保证，如果 A happens-before B，那么 A 在 modification order 里也应该在 B 的前面，当然对读操作而言是指从 modification order 里读到的那个写操作。</p>
<p>标记为 memory_relaxed_order 的原子操作对同步无贡献，不会帮助建立跨线程关系。这种原子操作只需要确保原子性，以及这 4 条规则就行。注意 happens-before 是包含了 intra-thread 关系的（sequenced-before，单线程里代码编写的先后顺序）。所以这些 relaxed 的原子操作在应用 4 条 modification order 规则的时候，规则里的 happens-before 关系对他们来说等价于 sequenced-before 关系。所以这就很像分布式系统里的读己所写，单调读之类的一致性保证。</p>
<p>如果觉得不太好理解，在 C++ Concurrency in Action 里作者举了个很不错的例子。</p>
<p>可以把每个变量想象成一个在小房间里的人，拿了个本子。这个本子上从上到下记录了一个值序列。你可以打电话问这个人要一个值，也可以打电话让他在本子上写下一个新的值。如果你第一次问他一个值，他可以随便从本子上选一个给你，然后在本子上把你的名字记在那个值的位置，以后再问他要一个值，他不能选择这个位置之前的值告诉你。如果你之后问他要一个值，他可以选你名字在的那个位置及以下的值给你，然后把你的名字更新在这个新的位置。如果你让他写入一个值，他会在值序列最后面追加写上你要写入的值，然后把你的名字更新到你写入的这个地方。</p>
<p><img src="fig5.5.png" alt="fig5.5"></p>
<p>比如当前本子上从上到下是 5, 10, 23, 3, 1, 2。当你读取得到了某个值，他可以从序列里任选一个告诉你，但是如果你后续再去读，他不能告诉你上一次的值之前的版本的值，比如第一次读到了10，第二次不能读到5，但是10, 23, 3, 1, 2 都是可以的。如果你取修改，比如写入42，那么下一次读取，不能读到42之前的值，但是42，67都是可以的，67是 Fred 写入的值，相当于另一个线程的写入。</p>
<p>这个举例里，那个人就是原子对象，那个本子上的值就是原子对象的 modification order。你，Fred，Dave 啥的就是不同的线程，你问这个人要一个值或者写入一个值就是这个线程里对该原子对象的原子读写操作，这些操作是按照代码顺序（sequenced-before 关系）执行的。</p>
<p>下面用一些 quiz 来加深理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);    <span class="comment">// 1</span></span><br><span class="line">    y.store(<span class="literal">true</span>,<span class="built_in">std</span>::memory_order_relaxed);    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_relaxed));  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed))       <span class="comment">// 4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x=<span class="literal">false</span>;</span><br><span class="line">    y=<span class="literal">false</span>;</span><br><span class="line">    z=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.join();</span><br><span class="line">    b.join();</span><br><span class="line">    assert(z.load()!=<span class="number">0</span>);                        <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// 这个 assert 会失败吗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照 C++ 标准，这个 assert 是可能失败的，<code>read_y_then_x</code> 可能先读到 y 是 true，再读到 x 是 false。不要凭感觉，仔细回顾标准。1 happens-before 2，3 happens-before 4。注意 x, y 是两个不同的原子变量。x, y 的 modification order 都是 false, true。想象一下前面那个举例，读 y 读到了 true，然后读 x 的时候是第一次读，读到 false 也并没有违背内存模型。</p>
<p>不过我在 Mac 上没有 assert fire 掉，因为 x86 的内存模型比较强（不存在 StoreStore, LoadLoad, LoadStore 重排），看编译出来的汇编发现编译器也没给做重排，所以没出问题。当然 x86 这个是和处理器的内存模型有关。本篇讨论的主要是 C++ 内存模型，这个是语言标准，规定了什么样的执行顺序是不应该发生的，<strong>哪些</strong> 执行顺序是允许的，实现的时候这个允许的集合里任选一个执行顺序都是 ok 的。</p>
<p>再来一个例子。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">if</span> (y.load(<span class="built_in">std</span>::memory_order_relaxed))</span><br><span class="line">        z++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">if</span> (x.load(<span class="built_in">std</span>::memory_order_relaxed))</span><br><span class="line">        z++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(f1)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(f2)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    assert(z != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 这个 assert 会失败吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按照标准，这个 assert 可能失败，t1 可能读到 y 是 0 同时 t2 也可能读到 x 是 0。happens-before 关系只在 f1, f2 执行的单个线程里有，还是之前的道理。比如 t1 里对 x 写入了 1，这只能保证 t1 后续读 x 读到比 1 更新的值，并不能确保别的线程能读到比 1 更新的。这次这个代码容易复现，因为这里出错可以是因为 StoraLoad 重排，x86 可能会有这种重排。我写了个 py 脚本反复调用这个程序，可以观察到 assert 失败。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    count = int(sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    count = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">args = [<span class="string">'a.out'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">    sp = subprocess.Popen(args, stderr=subprocess.PIPE, stdout=subprocess.PIPE)</span><br><span class="line">    out, err = sp.communicate()</span><br><span class="line">    <span class="keyword">if</span> sp.returncode != <span class="number">0</span>:</span><br><span class="line">        cmd = subprocess.list2cmdline(args)</span><br><span class="line">        print(<span class="string">f'[<span class="subst">&#123;i&#125;</span>] err: <span class="subst">&#123;err&#125;</span>'</span>)</span><br><span class="line">        <span class="keyword">raise</span> subprocess.CalledProcessError(sp.returncode, cmd, err)</span><br><span class="line">print(<span class="string">f'finish <span class="subst">&#123;count&#125;</span> tests'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[633] err: b<span class="string">'Assertion failed: (z != 0), function main, file relaxed_1.cc, line 23.\n'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"main.py"</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    raise subprocess.CalledProcessError(sp.returncode, cmd, err)</span><br><span class="line">subprocess.CalledProcessError: Command <span class="string">'a.out'</span> died with &lt;Signals.SIGABRT: 6&gt;.</span><br></pre></td></tr></table></figure>
<h4 id="Release-Acquire-ordering"><a href="#Release-Acquire-ordering" class="headerlink" title="Release-Acquire ordering"></a>Release-Acquire ordering</h4><p>在讲概念之前先瞎扯一些。release-acquire 顺序可以说是最容易理解，也很有意义的一个内存模型。acquire 和 release 就是来自互斥锁，信号量里的 acquire, release。acquire 是加锁，release 是释放锁。考虑一下编译器重排和处理器重排，如果 acquire 之后的代码被重排到了 acquire 的前面，或者 release 之前的代码被重排到了 release 的后面，这就意味着临界区的代码重排到了临界区之外，这是非常危险的。所以正确的锁实现一定要防止这种重排，锁带有这种语义，底层也是得用 release-acquire ordering 达成的。(Operations on a data structure (such as locking a mutex) might provide this relationship(synchronizes-with) if the data structure contains atomic types and the operations on that data structure perform the appropriate atomic operations internally, but fundamentally it comes only from operations on atomic types.[C++ Concurrency in Action])</p>
<p>release 标签是对写操作而言的，acquire 操作是对读操作而言的。一个写操作 release 了，直观上意思就是我发布一个写，你们看着点，在我之前的内存读写都应该对你们可见。acquire 操作得和同一个原子对象的 release 操作配对，如果这个 acquire 操作读到了 release 操作写入的值，那么 release 操作 synchronizes-with 这个 acquire 操作，acquire 操作后面的操作应该能够看见 release 之前的所有写入。</p>
<ul>
<li>memory_order_release, memory_order_acq_rel, and memory_order_seq_cst: a store operation performs a release operation on the affected memory location.</li>
<li>memory_order_acquire, memory_order_acq_rel, and memory_order_seq_cst: a load operation performs an acquire operation on the affected memory location.</li>
</ul>
<p>回顾一下标准里的这两条规则，memory_order_acquire 标签的 load operation 是一个 acquire operation，memory_order_release 标签的 store operation 是一个 release operation。</p>
<p>Certain library calls synchronize with other library calls performed by another thread. For example, an atomic store-release synchronizes with a load-acquire that takes its value from the store (29.3). </p>
<p>再回顾一下 synchronizes-with 的定义。可以推出如果一个 load-acquire 读到了 store-release 写入的值，那么 store-release happens-before load-acquire。这就建立了一个跨线程的关系：store-release 之前的代码 —&gt; store-release —&gt; load-acquire —&gt; load-acquire之后的代码。</p>
<p>看点代码加深一下理解：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt; ptr;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p  = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Hello"</span>);             <span class="comment">// 1</span></span><br><span class="line">    data = <span class="number">42</span>;                                              <span class="comment">// 2</span></span><br><span class="line">    ptr.store(p, <span class="built_in">std</span>::memory_order_release);                <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.load(<span class="built_in">std</span>::memory_order_acquire)))     <span class="comment">// 4</span></span><br><span class="line">        ;</span><br><span class="line">    assert(*p2 == <span class="string">"Hello"</span>); <span class="comment">// never fires                  // 5</span></span><br><span class="line">    assert(data == <span class="number">42</span>); <span class="comment">// never fires                      // 6</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>两个 assert 都不会失败，因为 4 这个循环结束之后，ptr.load 读到了 3 里写入的值。所以 3 synchronizes-with 4。通过代码的 sequenced-before 关系，可以知道 1 sequenced-before 2 sequenced-before 3，4 sequenced-before 5 sequenced-before 6。这样我们可以得到一个 happens-before 关系：1 —&gt; 2 —&gt; 3 —&gt; 4 —&gt; 5 —&gt; 6。</p>
<p>按照标准的定义，一个读取应该读到 happens-before 它的最近的一个同对象的写入（如果存在多个这样的写入就炸了）。在 happens-before 链里我们知道，对 6 来说，最近的同对象的写入是 2，所以 6 能看到 2 写入的值。1 和 5 同理。</p>
<h4 id="Release-Consume-ordering"><a href="#Release-Consume-ordering" class="headerlink" title="Release-Consume ordering"></a>Release-Consume ordering</h4><p>这个和 release-acquire ordering 类似，但是标准试图给 release-acquire ordering 做更加精细的精简，允许编译器做一些的重排。</p>
<p>当然只是标准，不知道现代编译器能不能做到这种精细的分析。前面提过，Note that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations. 而且从 C++17 开始，The specification of release-consume ordering is being revised, and the use of memory_order_consume is temporarily discouraged.</p>
<p>这次不做那么啰嗦的分析了，类似于前面对 Release-Acquire Ordering 的分析，参考标准 29.3 对特定标签原子操作的分类，以及基本概念和 Happens-Before 里 Happens-Before 的定义自己进行分析。下面给一个来自 cppreference 的代码例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt; ptr;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p  = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.store(p, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.load(<span class="built_in">std</span>::memory_order_consume)))</span><br><span class="line">        ;</span><br><span class="line">    assert(*p2 == <span class="string">"Hello"</span>); <span class="comment">// never fires: *p2 carries dependency from ptr</span></span><br><span class="line">    assert(data == <span class="number">42</span>); <span class="comment">// may or may not fire: data does not carry dependency from ptr</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Sequentially-consistent-ordering"><a href="#Sequentially-consistent-ordering" class="headerlink" title="Sequentially-consistent ordering"></a>Sequentially-consistent ordering</h4><p>Atomic operations tagged memory_order_seq_cst not only order memory the same way as release/acquire ordering (everything that happened-before a store in one thread becomes a visible side effect in the thread that did a load), but also establish a single total modification order of all atomic operations that are so tagged. [cppreference]</p>
<p>There shall be a single total order S on all memory_order_seq_cst operations, consistent with the “happens before” order and modification orders for all affected locations, such that each memory_order_seq_cst operation B that loads a value from an atomic object M observes one of the following values:</p>
<ul>
<li>the result of the last modification A of M that precedes B in S, if it exists, or</li>
<li>if A exists, the result of some modification of M in the visible sequence of side effects with respect to B that is not memory_order_seq_cst and that does not happen before A, or</li>
<li>if A does not exist, the result of some modification of M in the visible sequence of side effects with respect to B that is not memory_order_seq_cst.</li>
</ul>
<p>[c++ standard 29.3 atomics.order]</p>
<p>所有带有 memory_order_seq_cst 标签的原子操作，如果是读操作，是 acquire operation (memory_order_acquire)，如果是写操作，是 release operation (memory_order_release)，如果是 read-modify-write 操作，同时具备 release 和 acquire (memory_order_acq_rel)，并且，所有 memory_order_seq_cst 的原子操作存在一个单独的全序（顺序一致性）。这个全序不能违背 happens-before 关系。</p>
<p>来点示例代码，这段代码就是把前面 relaxed ordering 里的一段代码的标签全部换成 seq_cst：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_seq_cst);      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (y.load(<span class="built_in">std</span>::memory_order_seq_cst))      <span class="comment">// 2</span></span><br><span class="line">        z++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_seq_cst);      <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (x.load(<span class="built_in">std</span>::memory_order_seq_cst))      <span class="comment">// 4</span></span><br><span class="line">        z++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(f1)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(f2)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    assert(z != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 这个 assert 会失败吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>assert 不会失败，因为 1，2，3，4 都带了 seq_cst，且 1 sequenced before 2, 3 sequenced before 4。那么两个线程对1，2，3，4的顺序有一个一致的全局定序，且满足 1 在 2 之前，3 在 4 之前。所以这个全序的最后只能是 2 或者 4，最前只能是 1 或者 3，从而 2，4 里至少有一个能读到 1，3 写入的值，z++ 至少会执行一次。仔细看的话会发现这里其实禁止了 StoreLoad 重排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_seq_cst);       <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_seq_cst);       <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (y.load(<span class="built_in">std</span>::memory_order_seq_cst))          <span class="comment">// 3</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.load(<span class="built_in">std</span>::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (x.load(<span class="built_in">std</span>::memory_order_seq_cst))          <span class="comment">// 4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.join(); b.join(); c.join(); d.join();</span><br><span class="line">    assert(z.load() != <span class="number">0</span>);                          <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// 这个 assert 会失败吗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码来自 C++ Concurrency in Action。这个 assert 决不会失败，具体的分析类似于前一例，不展开讲了，结合定义可以得出结论。</p>
<p>要注意，memory_order_seq_cst 标签只是意味着每个原子操作都有 release-acquire 语义，加上一个全局定序，所有线程对这些 seq_cst 标签的操作都看到相同的全局定序。但也仅仅如此：</p>
<ol>
<li>这并不意味着 memory_order_seq_cst 操作可以禁止(与 non-atomic 或者非 seq_cst 操作的) StoreLoad 重排序</li>
<li>对于非 memory_order_seq_cst 标签的操作可以不遵守这个全序</li>
</ol>
<p>on x86_64, Usually - if in compilers seq_cst implemented as barrier after store, then:  STORE-C(relaxed); LOAD-B(seq_cst); can be reordered to LOAD-B(seq_cst); STORE-C(relaxed); Also, theoretically possible - if in compilers seq_cst implemented as barrier before load, then: STORE-A(seq_cst); LOAD-C(acq_rel); can be reordered to LOAD-C(acq_rel); STORE-A(seq_cst);</p>
<p>On x86_64, STORE-C(release); LOAD-B(seq_cst); can be reordered to LOAD-B(seq_cst); STORE-C(release);</p>
<p><a href="http://www.intel.com/Assets/en_US/PDF/manual/253668.pdf" target="_blank" rel="noopener">Intel® 64 and IA-32 Architectures</a></p>
<blockquote>
<p>8.2.3.4 Loads May Be Reordered with Earlier Stores to Different Locations</p>
</blockquote>
<p>I.e. x86_64 code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STORE-A(seq_cst);</span><br><span class="line">STORE-C(release); </span><br><span class="line">LOAD-B(seq_cst);</span><br></pre></td></tr></table></figure></p>
<p>Can be reordered to:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STORE-A(seq_cst);</span><br><span class="line">LOAD-B(seq_cst);</span><br><span class="line">STORE-C(release);</span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这一篇就讲到这里，写了挺久的，中间经历了各种事情比如入职，学 JAVA 啥的。最后发现篇幅也太长了，从标准里抄了很多东西，然后为了讲清楚就反复啰嗦那几个概念。其实到这里并没有全部讲完，比如 release sequence rule，fence，其他的一些建立 inter-thread 关系的情况都没有讲，还想再举一些例子来着。不过这一篇就到这里吧，这些内容开篇新的补充。</p>
<p>参考资料：</p>
<ol>
<li>C++ Standard </li>
<li><a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">cppreference memory_order</a></li>
<li>C++ Concurrency in Action</li>
<li><a href="https://stackoverflow.com/questions/39053600/does-standard-c11-guarantee-that-memory-order-seq-cst-prevents-storeload-reord" target="_blank" rel="noopener">does-standard-c11-guarantee-that-memory-order-seq-cst-prevents-storeload-reord</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html" target="_blank" rel="noopener">Java Language Specification, Chapter 17. Threads and Locks</a></li>
</ol>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="https://blog.runc.dev">shengrang</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://blog.runc.dev/2020/02/22/introduction-to-concurrency-programming-2/">https://blog.runc.dev/2020/02/22/introduction-to-concurrency-programming-2/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>
            </div>
        
        <nav class="post-nav"><a class="next" href="/2020/02/22/introduction-to-concurrency-programming-1/">
        <span class="next-text nav-default">并发编程基础 - 重排序和屏障</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="https://github.com/shengrang" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">shengrang</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.1"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
